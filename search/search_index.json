{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#datarails-a-simple-lightweight-framework-for-dataframe-etl","title":"datarails -- A Simple, Lightweight Framework for Dataframe ETL","text":""},{"location":"#-version-032-","title":"-- VERSION 0.3.2 --","text":"<p>Datarails is a simple framework for organizing your in memory Dataframe based ETL jobs. It doesn't matter of you are using <code>pandas</code>, <code>spark</code>, <code>glue</code> or anything else this library serves as a simple way to structure your ETL jobs. It is not a replacement for <code>airflow</code>, <code>luigi</code>, <code>dagster</code> or any other workflow management tool, but rather can serve as the \"entry point\" for your workflow management tool to execute your ETL job.</p>"},{"location":"#official-documentation","title":"Official Documentation","text":"<p>The official documentation is hosted on github pages at jesse.maitland.github.io</p>"},{"location":"#installation","title":"Installation","text":"<p>Datarails is available on PyPI and can be installed with pip. It has no dependencies and is written in pure python.</p> <pre><code>pip install datarails\n</code></pre>"},{"location":"#features","title":"Features","text":"<p>Datarails consists of 4 main classes:</p> <p>DataBox: A dynamic data store for DataFrame objects. It can handle any DataFrame type, and offers methods for adding, retrieving, and removing data. It's a bit like a dictionary for DataFrames.</p> <p>DataRailsContext: A companion to DataBox, this class is designed for storing and retrieving additional data that you may need alongside your DataFrame objects. It allows you to associate metadata, configuration details, and other supplementary information with your data.</p> <p>DataRailsStepRunner: This class is responsible for running a sequence of DataRailsStep objects. It takes a DataBox as input and manages the execution of each step, tracking the state of the DataBox as it goes.</p> <p>DataRailsStep: A base class for defining steps in your data pipeline. By inheriting from this class, you can create custom steps that fit your specific needs.</p>"},{"location":"#simple-example","title":"Simple Example","text":"<p>ETL steps are defined as classes and then passed to a step runner. All methods in the class that start with <code>step_</code> will be run in the order they are defined. Each step has access to a <code>DataBox</code> object that can be used to store dataframes and access them by name in downstream steps.</p> <p>In addition to the <code>DataBox</code> object, each step has access to a <code>DataRailsContext</code> object that can be used to store and access variables that are not dataframes.</p> <p>In this below example we are doing some simple procssing using pandas, however any other dataframe library could be used.</p> <pre><code>import pandas as pd\nfrom datarails.step import DataRailsStep\nfrom datarails.runner import DataRailsStepRunner\n\n\nclass LoadDataFromCSV(DataRailsStep):\n    \"\"\"Loads data from a CSV file into a DataBox.\"\"\"\n\n    def step_load_csv(self) -&gt; None:\n        \"\"\"Loads a DataFrame from a CSV file and stores it in the DataBox under 'data'.\"\"\"\n        print('loading data from csv')\n        df = pd.read_csv('data.csv')\n        self.dbx.put_df('data', df)\n\n\nclass TransformData(DataRailsStep):\n    \"\"\"Applies transformation operations to a DataFrame stored in a DataBox.\"\"\"\n\n    def step_add_new_column(self) -&gt; None:\n        \"\"\"Adds a new column to the DataFrame which is double the values of the 'old_column'.\"\"\"\n        print('adding new column')\n        self.dbx.data['new_column'] = self.dbx.data['old_column'] * 2\n\n    def step_drop_all_null_rows(self) -&gt; None:\n        \"\"\"Removes all rows from the DataFrame that contain any null values.\"\"\"\n        print('dropping null rows')\n        self.dbx.data = self.dbx.data.dropna()\n\n    def step_rename_columns(self) -&gt; None:\n        \"\"\"Renames the 'new_column' in the DataFrame to 'blue_column'.\"\"\"\n        print('renaming columns')\n        self.dbx.data = self.dbx.data.rename(columns={'new_column': 'blue_column'})\n\n\nclass SaveData(DataRailsStep):\n    \"\"\"Saves the DataFrame from a DataBox to a CSV file.\"\"\"\n\n    def step_save_data(self) -&gt; None:\n        \"\"\"Saves the DataFrame to a CSV file named 'new_data.csv'.\"\"\"\n        print('saving data')\n        self.dbx.data.to_csv('new_data.csv')\n\n\n# gather your steps in a list of class definitions. The class instances will be created by the step runner\n# while the jobs is being executed.\nsteps = [\n    LoadDataFromCSV,\n    TransformData,\n    SaveData\n]\n\n# pass your steps to the step runner\nrunner = DataRailsStepRunner(steps=steps)\n\n# Run the job. The steps will be run in the order they are defined in the list. Each method declared in a step will be\n# executed in the order they are defined in the class.\n\nif __name__ == '__main__':\n    runner.run()\n\n</code></pre>"},{"location":"#example-project","title":"Example Project","text":"<p>There is an example repo containing some simple ETL jobs, notebooks and commands for building documentation at jessemaitland/datarails-example</p>"},{"location":"#why-use-datarails","title":"Why Use DataRails?","text":"<p><code>datarails</code> addresses several critical issues commonly encountered during the execution of small to medium scale ETL (Extract, Transform, Load) scripts in Python. While simple, it is an effective framework that streamlines ETL tasks, and serves as a robust \"entry point\" for other workflow management tools, like <code>airflow</code>, <code>luigi</code>, or <code>dagster</code>, to execute your ETL job.</p>"},{"location":"#1-segmenting-your-etl-job-into-manageable-steps","title":"1. Segmenting Your ETL Job into Manageable Steps","text":"<p>ETL tasks of small or medium complexity can often transform into a single, monolithic script. While functional, this approach could be challenging to debug when data-related errors occur. <code>datarails</code> allows the segmentation of ETL tasks into distinct, manageable steps, enhancing clarity and error-handling.</p>"},{"location":"#2-navigating-your-etl-job-step-by-step","title":"2. Navigating Your ETL Job Step by Step","text":"<p>With <code>datarails</code>, it's possible to debug ETL jobs step-by-step. You can import your runner into a Python shell or a Jupyter notebook, advancing through each step individually. This method is particularly beneficial when working with schema-less source data formats like JSON or CSV, enabling precise data inspection at every stage.</p> <pre><code>from my_etl_job import runner\nrunner.advance() # run the next step and stop execution\n\nstep_to_debug = runner.get_current_step() # get the current step\n\nstep_to_debug.dbx.data # inspect the data in the DataBox\nstep_to_debug.dbx.context # inspect the context in the DataRailsContext\n\nstep_to_debug.advance() # run the next step and stop execution. Repeat as needed.\n</code></pre>"},{"location":"#3-a-practical-solution-for-typical-data-sizes","title":"3. A Practical Solution for Typical Data Sizes","text":"<p>Most often, external processes fetch data and upload it into S3 (or similar cloud storage) on a daily basis. The data, typically in the size range of 20MB to 100MB and in diverse formats like <code>json</code>, <code>json lines</code>, or <code>csv</code>, needs transformation and cleaning before it can be utilized by other teams in your data lake or warehouse. <code>datarails</code> is an ideal library for managing and transforming these types of data.</p>"},{"location":"#4-simplified-documentation","title":"4. Simplified Documentation","text":"<p><code>datarails</code> encourages the practice of dividing ETL jobs into smaller methods, thus facilitating the process of documentation. This feature works well with Python's native tools for generating documentation from docstrings, and such documentation can be published through your CI job. This way, it is readily available for business users or other technical users, significantly reducing the time you spend responding to queries about your ETL jobs.</p>"},{"location":"#5-facilitating-standardization-across-the-organization","title":"5. Facilitating Standardization Across the Organization","text":"<p>In many organizations, ETL processes and data pipelines can be constructed in vastly different ways depending on the preferences and experience of individual developers. This can lead to considerable confusion, difficulty in maintaining code, and barriers to effective collaboration. <code>datarails</code> can help overcome these challenges by offering a standard framework for developing ETL jobs.</p> <p>The use of <code>datarails</code> ensures that all ETL scripts follow the same structure and approach, creating a uniform coding style across the organization. This not only makes the codebase easier to understand and maintain, but also encourages effective collaboration between team members. Moreover, the standardized structure can expedite the onboarding process for new team members, as they only need to familiarize themselves with one framework, rather than a multitude of disparate coding styles.</p>"},{"location":"context/","title":"DataRailsContext","text":"<p>To use this class</p> <pre><code>from datarails.contexts import DataRailsContext\n</code></pre> <p>             Bases: <code>_BaseContext</code></p> <p>DataRailsContext provides an interface to interact with its data.</p> Source code in <code>datarails/contexts.py</code> <pre><code>class DataRailsContext(_BaseContext):\n\"\"\"DataRailsContext provides an interface to interact with its data.\"\"\"\n\n    def __str__(self) -&gt; str:\n\"\"\"Returns a string representation of the context.\"\"\"\n        return f\"DataRailsContext({self.list_contents()})\"\n\n    def get(self, name: str) -&gt; Union[Any, None]:\n\"\"\"\n        Gets a value from the context based on its name.\n\n        Args:\n            name (str): The name of the value to get.\n\n        Returns:\n            Union[Any, None]: The value associated with the name, or None if it doesn't exist.\n        \"\"\"\n        return self._get(name)\n\n    def put(self, name: str, value: Any) -&gt; None:\n\"\"\"\n        Puts a value into the context with a specified name.\n\n        Args:\n            name (str): The name to associate with the value.\n            value (Any): The value to put into the context.\n        \"\"\"\n        self._put(name, value)\n\n    def pop(self, name: str) -&gt; DataFrame:\n\"\"\"\n        Pops a value from the context based on its name.\n\n        Args:\n            name (str): The name of the value to pop.\n\n        Returns:\n            DataFrame: The DataFrame associated with the name.\n        \"\"\"\n        return self._pop(name)\n\n    def delete(self, name: str) -&gt; None:\n\"\"\"\n        Deletes a value from the context based on its name.\n\n        Args:\n            name (str): The name of the value to delete.\n        \"\"\"\n        self._delete(name)\n</code></pre>"},{"location":"context/#datarails.contexts.DataRailsContext.__str__","title":"<code>__str__()</code>","text":"<p>Returns a string representation of the context.</p> Source code in <code>datarails/contexts.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns a string representation of the context.\"\"\"\n    return f\"DataRailsContext({self.list_contents()})\"\n</code></pre>"},{"location":"context/#datarails.contexts.DataRailsContext.delete","title":"<code>delete(name)</code>","text":"<p>Deletes a value from the context based on its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the value to delete.</p> required Source code in <code>datarails/contexts.py</code> <pre><code>def delete(self, name: str) -&gt; None:\n\"\"\"\n    Deletes a value from the context based on its name.\n\n    Args:\n        name (str): The name of the value to delete.\n    \"\"\"\n    self._delete(name)\n</code></pre>"},{"location":"context/#datarails.contexts.DataRailsContext.get","title":"<code>get(name)</code>","text":"<p>Gets a value from the context based on its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the value to get.</p> required <p>Returns:</p> Type Description <code>Union[Any, None]</code> <p>Union[Any, None]: The value associated with the name, or None if it doesn't exist.</p> Source code in <code>datarails/contexts.py</code> <pre><code>def get(self, name: str) -&gt; Union[Any, None]:\n\"\"\"\n    Gets a value from the context based on its name.\n\n    Args:\n        name (str): The name of the value to get.\n\n    Returns:\n        Union[Any, None]: The value associated with the name, or None if it doesn't exist.\n    \"\"\"\n    return self._get(name)\n</code></pre>"},{"location":"context/#datarails.contexts.DataRailsContext.pop","title":"<code>pop(name)</code>","text":"<p>Pops a value from the context based on its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the value to pop.</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>The DataFrame associated with the name.</p> Source code in <code>datarails/contexts.py</code> <pre><code>def pop(self, name: str) -&gt; DataFrame:\n\"\"\"\n    Pops a value from the context based on its name.\n\n    Args:\n        name (str): The name of the value to pop.\n\n    Returns:\n        DataFrame: The DataFrame associated with the name.\n    \"\"\"\n    return self._pop(name)\n</code></pre>"},{"location":"context/#datarails.contexts.DataRailsContext.put","title":"<code>put(name, value)</code>","text":"<p>Puts a value into the context with a specified name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name to associate with the value.</p> required <code>value</code> <code>Any</code> <p>The value to put into the context.</p> required Source code in <code>datarails/contexts.py</code> <pre><code>def put(self, name: str, value: Any) -&gt; None:\n\"\"\"\n    Puts a value into the context with a specified name.\n\n    Args:\n        name (str): The name to associate with the value.\n        value (Any): The value to put into the context.\n    \"\"\"\n    self._put(name, value)\n</code></pre>"},{"location":"databox/","title":"DataBox","text":"<p>This is a description of the <code>DataBox</code> class. It is intended to be used as a container to store dataframes and allow them to be  accessible by name to downstream ETL steps.</p> <p>To use this class</p> <pre><code>from datarails.contexts import DataBox\n</code></pre> <p>             Bases: <code>_BaseContext</code></p> <p>DataBox provides an interface to interact with its DataFrame data.</p> Source code in <code>datarails/contexts.py</code> <pre><code>class DataBox(_BaseContext):\n\"\"\"DataBox provides an interface to interact with its DataFrame data.\"\"\"\n\n    def __str__(self) -&gt; str:\n\"\"\"Returns a string representation of the DataBox.\"\"\"\n        return f\"DataBox({self.list_contents()})\"\n\n    def get_df(self, name: str) -&gt; DataFrame:\n\"\"\"\n        Gets a DataFrame from the DataBox based on its name.\n\n        Args:\n            name (str): The name of the DataFrame to get.\n\n        Returns:\n            DataFrame: The DataFrame associated with the name.\n        \"\"\"\n        return self._get(name)\n\n    def put_df(self, name: str, df: DataFrame) -&gt; None:\n\"\"\"\n        Puts a DataFrame into the DataBox with a specified name.\n\n        Args:\n            name (str): The name to associate with the DataFrame.\n            df (DataFrame): The DataFrame to put into the DataBox.\n        \"\"\"\n        self._put(name, df)\n\n    def pop_df(self, name: str) -&gt; DataFrame:\n\"\"\"\n        Pops a DataFrame from the DataBox based on its name.\n\n        Args:\n            name (str): The name of the DataFrame to pop.\n\n        Returns:\n            DataFrame: The DataFrame associated with the name.\n        \"\"\"\n        return self._pop(name)\n\n    def delete_df(self, name: str) -&gt; None:\n\"\"\"\n        Deletes a DataFrame from the DataBox based on its name.\n\n        Args:\n            name (str): The name of the DataFrame to delete.\n        \"\"\"\n        self._delete(name)\n</code></pre>"},{"location":"databox/#datarails.contexts.DataBox.__str__","title":"<code>__str__()</code>","text":"<p>Returns a string representation of the DataBox.</p> Source code in <code>datarails/contexts.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Returns a string representation of the DataBox.\"\"\"\n    return f\"DataBox({self.list_contents()})\"\n</code></pre>"},{"location":"databox/#datarails.contexts.DataBox.delete_df","title":"<code>delete_df(name)</code>","text":"<p>Deletes a DataFrame from the DataBox based on its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the DataFrame to delete.</p> required Source code in <code>datarails/contexts.py</code> <pre><code>def delete_df(self, name: str) -&gt; None:\n\"\"\"\n    Deletes a DataFrame from the DataBox based on its name.\n\n    Args:\n        name (str): The name of the DataFrame to delete.\n    \"\"\"\n    self._delete(name)\n</code></pre>"},{"location":"databox/#datarails.contexts.DataBox.get_df","title":"<code>get_df(name)</code>","text":"<p>Gets a DataFrame from the DataBox based on its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the DataFrame to get.</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>The DataFrame associated with the name.</p> Source code in <code>datarails/contexts.py</code> <pre><code>def get_df(self, name: str) -&gt; DataFrame:\n\"\"\"\n    Gets a DataFrame from the DataBox based on its name.\n\n    Args:\n        name (str): The name of the DataFrame to get.\n\n    Returns:\n        DataFrame: The DataFrame associated with the name.\n    \"\"\"\n    return self._get(name)\n</code></pre>"},{"location":"databox/#datarails.contexts.DataBox.pop_df","title":"<code>pop_df(name)</code>","text":"<p>Pops a DataFrame from the DataBox based on its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the DataFrame to pop.</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>DataFrame</code> <p>The DataFrame associated with the name.</p> Source code in <code>datarails/contexts.py</code> <pre><code>def pop_df(self, name: str) -&gt; DataFrame:\n\"\"\"\n    Pops a DataFrame from the DataBox based on its name.\n\n    Args:\n        name (str): The name of the DataFrame to pop.\n\n    Returns:\n        DataFrame: The DataFrame associated with the name.\n    \"\"\"\n    return self._pop(name)\n</code></pre>"},{"location":"databox/#datarails.contexts.DataBox.put_df","title":"<code>put_df(name, df)</code>","text":"<p>Puts a DataFrame into the DataBox with a specified name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name to associate with the DataFrame.</p> required <code>df</code> <code>DataFrame</code> <p>The DataFrame to put into the DataBox.</p> required Source code in <code>datarails/contexts.py</code> <pre><code>def put_df(self, name: str, df: DataFrame) -&gt; None:\n\"\"\"\n    Puts a DataFrame into the DataBox with a specified name.\n\n    Args:\n        name (str): The name to associate with the DataFrame.\n        df (DataFrame): The DataFrame to put into the DataBox.\n    \"\"\"\n    self._put(name, df)\n</code></pre>"},{"location":"runner/","title":"StepRunner","text":"<p>This is a description of the <code>StepRunner</code> class. It is intended to be used as a container and runner for all ETL DataRailsStep child classes. Steps are run in the order they are added to the runner. The constructor take a list of step class definitions.  A DataBox will be created automatically in the constructor and passed to each step as the execution progresses.</p> <p>To use this class</p> <pre><code>from datarails.runner import DataRailsStepRunner\n</code></pre> <p>This class orchestrates the execution of a sequence of DataRailsSteps. It primarily uses DataBox as input, advancing through the steps and managing the DataBox state.</p> <p>Attributes:</p> Name Type Description <code>steps</code> <code>List[Type[DataRailsStep]]</code> <p>The ordered list of step classes to be executed.</p> <code>dbx</code> <code>DataBox</code> <p>The DataBox object for data management.</p> <code>ctx</code> <code>DataRailsContext</code> <p>The DataRailsContext object for context management.</p> Source code in <code>datarails/runner.py</code> <pre><code>class DataRailsStepRunner:\n\"\"\"\n    This class orchestrates the execution of a sequence of DataRailsSteps. It primarily uses\n    DataBox as input, advancing through the steps and managing the DataBox state.\n\n    Attributes:\n        steps (List[Type[DataRailsStep]]): The ordered list of step classes to be executed.\n        dbx (DataBox): The DataBox object for data management.\n        ctx (DataRailsContext): The DataRailsContext object for context management.\n    \"\"\"\n\n    def __init__(\n        self, steps: List[Type[DataRailsStep]], dbx: Optional[DataBox] = None, ctx: Optional[DataRailsContext] = None\n    ) -&gt; None:\n\"\"\"\n        Initializes the StepRunner object with a list of DataRailsStep classes.\n\n        Args:\n            steps (List[Type[DataRailsStep]]): The list of step classes to be executed.\n            dbx (DataBox, optional): The DataBox object. If not provided, a new one is created.\n            ctx (DataRailsContext, optional): The DataRailsContext object. If not provided, a new one is created.\n        \"\"\"\n        self.steps = steps\n        self.dbx = dbx or DataBox()\n        self.ctx = ctx or DataRailsContext()\n        self._i = 0\n\n    def reset(self):\n\"\"\"\n        Resets the steps_iterator to its initial state, enabling the step sequence to be run again from the start.\n        \"\"\"\n        self._i = 0\n\n    def _i_in_bounds(self) -&gt; bool:\n\"\"\"\n        Checks if the current index is within the bounds of the steps list.\n\n        Returns:\n            bool: True if the index is in bounds, False otherwise.\n        \"\"\"\n        return 0 &lt;= self._i &lt; len(self.steps)\n\n    def get_current_step(self):\n\"\"\"\n        Retrieves the current step instance based on the index.\n\n        Returns:\n            DataRailsStep: The current step instance.\n        \"\"\"\n        return self.steps[self._i](self.dbx, self.ctx)\n\n    def print_current_step(self) -&gt; None:\n\"\"\"\n        Prints the details of the current step to standard output.\n        \"\"\"\n        step_instance = self.get_current_step()\n        print(f\"The Current Step : {self._i} : {step_instance}\")\n\n    def advance(self) -&gt; None:\n\"\"\"\n        Executes the current step in the steps list and advances the index to the next one.\n        Prints a message if there are no more steps to execute.\n        \"\"\"\n        if self._i_in_bounds():\n            current_step_instance = self.get_current_step()\n            print(f\"Running step: {self._i} : {current_step_instance}\")\n            self.dbx = current_step_instance.run()\n            self._i += 1\n        else:\n            print(\"All Steps Completed.\")\n\n    def run(self) -&gt; None:\n\"\"\"\n        Executes all steps in the steps list. If all steps have been completed, it stops the execution.\n        \"\"\"\n        while self._i_in_bounds():\n            self.advance()\n</code></pre>"},{"location":"runner/#datarails.runner.DataRailsStepRunner.__init__","title":"<code>__init__(steps, dbx=None, ctx=None)</code>","text":"<p>Initializes the StepRunner object with a list of DataRailsStep classes.</p> <p>Parameters:</p> Name Type Description Default <code>steps</code> <code>List[Type[DataRailsStep]]</code> <p>The list of step classes to be executed.</p> required <code>dbx</code> <code>DataBox</code> <p>The DataBox object. If not provided, a new one is created.</p> <code>None</code> <code>ctx</code> <code>DataRailsContext</code> <p>The DataRailsContext object. If not provided, a new one is created.</p> <code>None</code> Source code in <code>datarails/runner.py</code> <pre><code>def __init__(\n    self, steps: List[Type[DataRailsStep]], dbx: Optional[DataBox] = None, ctx: Optional[DataRailsContext] = None\n) -&gt; None:\n\"\"\"\n    Initializes the StepRunner object with a list of DataRailsStep classes.\n\n    Args:\n        steps (List[Type[DataRailsStep]]): The list of step classes to be executed.\n        dbx (DataBox, optional): The DataBox object. If not provided, a new one is created.\n        ctx (DataRailsContext, optional): The DataRailsContext object. If not provided, a new one is created.\n    \"\"\"\n    self.steps = steps\n    self.dbx = dbx or DataBox()\n    self.ctx = ctx or DataRailsContext()\n    self._i = 0\n</code></pre>"},{"location":"runner/#datarails.runner.DataRailsStepRunner.advance","title":"<code>advance()</code>","text":"<p>Executes the current step in the steps list and advances the index to the next one. Prints a message if there are no more steps to execute.</p> Source code in <code>datarails/runner.py</code> <pre><code>def advance(self) -&gt; None:\n\"\"\"\n    Executes the current step in the steps list and advances the index to the next one.\n    Prints a message if there are no more steps to execute.\n    \"\"\"\n    if self._i_in_bounds():\n        current_step_instance = self.get_current_step()\n        print(f\"Running step: {self._i} : {current_step_instance}\")\n        self.dbx = current_step_instance.run()\n        self._i += 1\n    else:\n        print(\"All Steps Completed.\")\n</code></pre>"},{"location":"runner/#datarails.runner.DataRailsStepRunner.get_current_step","title":"<code>get_current_step()</code>","text":"<p>Retrieves the current step instance based on the index.</p> <p>Returns:</p> Name Type Description <code>DataRailsStep</code> <p>The current step instance.</p> Source code in <code>datarails/runner.py</code> <pre><code>def get_current_step(self):\n\"\"\"\n    Retrieves the current step instance based on the index.\n\n    Returns:\n        DataRailsStep: The current step instance.\n    \"\"\"\n    return self.steps[self._i](self.dbx, self.ctx)\n</code></pre>"},{"location":"runner/#datarails.runner.DataRailsStepRunner.print_current_step","title":"<code>print_current_step()</code>","text":"<p>Prints the details of the current step to standard output.</p> Source code in <code>datarails/runner.py</code> <pre><code>def print_current_step(self) -&gt; None:\n\"\"\"\n    Prints the details of the current step to standard output.\n    \"\"\"\n    step_instance = self.get_current_step()\n    print(f\"The Current Step : {self._i} : {step_instance}\")\n</code></pre>"},{"location":"runner/#datarails.runner.DataRailsStepRunner.reset","title":"<code>reset()</code>","text":"<p>Resets the steps_iterator to its initial state, enabling the step sequence to be run again from the start.</p> Source code in <code>datarails/runner.py</code> <pre><code>def reset(self):\n\"\"\"\n    Resets the steps_iterator to its initial state, enabling the step sequence to be run again from the start.\n    \"\"\"\n    self._i = 0\n</code></pre>"},{"location":"runner/#datarails.runner.DataRailsStepRunner.run","title":"<code>run()</code>","text":"<p>Executes all steps in the steps list. If all steps have been completed, it stops the execution.</p> Source code in <code>datarails/runner.py</code> <pre><code>def run(self) -&gt; None:\n\"\"\"\n    Executes all steps in the steps list. If all steps have been completed, it stops the execution.\n    \"\"\"\n    while self._i_in_bounds():\n        self.advance()\n</code></pre>"},{"location":"step/","title":"DataRailsStep","text":"<p>This is a description of the <code>DataRailsSteps</code> class. It is intended to be used as a base class for all steps in a DataRails ETL workflow. </p> <p>When a child class is created, all methods that are declared with the prefix <code>step_</code> will be executed in the order that they are declared.  It is intended that each step will perform a single task, such as loading a file, or transforming data. The smaller the piece of work the better.</p> <p>Each step has an attribute called <code>dbx</code> which is an instance of a <code>DataBox</code>. This is a container for all the data that is being processed and will be automatically passed to each step as the execution progresses.</p> <p>To use this class</p> <pre><code>from datarails.step import DataRailsStep\n</code></pre> <p>Represents a step in a data pipeline process. This class is meant to be inherited from and not used directly. All methods that are declared with the prefix 'step_' in the child class will be run in the order they are declared.</p> <p>Attributes:</p> Name Type Description <code>dbx</code> <code>DataBox</code> <p>The data box object that stores and handles data for the step.</p> <code>ctx</code> <code>DataRailsContext</code> <p>The context object that provides additional data and functionality.</p> <code>on_entry_callback</code> <code>Callable</code> <p>The function to call upon entering a step. Default is None.</p> <code>on_exit_callback</code> <code>Callable</code> <p>The function to call upon exiting a step. Default is None.</p> <code>step_method_name_iterator</code> <code>Iterator</code> <p>An iterator that yields names of step methods.</p> Source code in <code>datarails/step.py</code> <pre><code>class DataRailsStep(metaclass=_StepMeta):\n\"\"\"\n    Represents a step in a data pipeline process. This class is meant to be inherited from and not used directly.\n    All methods that are declared with the prefix 'step_' in the child class will be run in the order they are declared.\n\n    Attributes:\n        dbx (DataBox): The data box object that stores and handles data for the step.\n        ctx (DataRailsContext): The context object that provides additional data and functionality.\n        on_entry_callback (Callable, optional): The function to call upon entering a step. Default is None.\n        on_exit_callback (Callable, optional): The function to call upon exiting a step. Default is None.\n        step_method_name_iterator (Iterator): An iterator that yields names of step methods.\n    \"\"\"\n\n    def __init__(\n        self,\n        dbx: DataBox,\n        ctx: DataRailsContext,\n        on_entry_callback: Optional[Callable] = None,\n        on_exit_callback: Optional[Callable] = None,\n    ) -&gt; None:\n\"\"\"\n        Constructs all the necessary attributes for the DataRailsStep object.\n\n        Args:\n            dbx (DataBox): The data box object that stores and handles data for the step.\n            ctx (DataRailsContext): The context object that provides additional data and functionality.\n            on_entry_callback (Callable, optional): The function to call upon entering a step. Default is None.\n            on_exit_callback (Callable, optional): The function to call upon exiting a step. Default is None.\n        \"\"\"\n        self.dbx = dbx\n        self.ctx = ctx\n        self.on_entry_callback = on_entry_callback\n        self.on_exit_callback = on_exit_callback\n        self.step_method_name_iterator = None\n\n    def __str__(self) -&gt; str:\n\"\"\"\n        Returns a user-friendly string representation of the instance, in this case, the class name.\n\n        Returns:\n            str: The name of the class.\n        \"\"\"\n        return self.__class__.__name__\n\n    def reset(self) -&gt; None:\n\"\"\"\n        Resets the iterator that yields names of step methods, allowing the steps to be run from the beginning.\n        \"\"\"\n        self.step_method_name_iterator = None\n\n    def run(self) -&gt; DataBox:\n\"\"\"\n        Runs all the steps in the order they were declared in the child class.\n        The order is fixed and cannot be changed. Each 'step_' method is called in turn.\n\n        on_entry_callback is called at the beginning, if provided.\n        on_exit_callback is called at the end, if provided.\n\n        Returns:\n            DataBox: The updated DataBox after all steps have been run.\n        \"\"\"\n        if self.on_entry_callback:\n            self.on_entry_callback()\n\n        for method_name in self.step_methods:\n            method = getattr(self, method_name)\n            method()\n\n        if self.on_exit_callback:\n            self.on_exit_callback()\n\n        return self.dbx\n\n    def advance(self) -&gt; None:\n\"\"\"\n        Advances to the next 'step_' method in the pipeline, if available.\n        This method can be used to control the execution of steps, for example in debugging scenarios.\n        \"\"\"\n\n        if not self.step_method_name_iterator:\n            self.step_method_name_iterator = iter(self.step_methods)\n\n        method_name = next(self.step_method_name_iterator, None)\n\n        if method_name:\n            method = getattr(self, method_name)\n            method()\n        else:\n            print(\"All steps have been executed.\")\n</code></pre>"},{"location":"step/#datarails.step.DataRailsStep.__init__","title":"<code>__init__(dbx, ctx, on_entry_callback=None, on_exit_callback=None)</code>","text":"<p>Constructs all the necessary attributes for the DataRailsStep object.</p> <p>Parameters:</p> Name Type Description Default <code>dbx</code> <code>DataBox</code> <p>The data box object that stores and handles data for the step.</p> required <code>ctx</code> <code>DataRailsContext</code> <p>The context object that provides additional data and functionality.</p> required <code>on_entry_callback</code> <code>Callable</code> <p>The function to call upon entering a step. Default is None.</p> <code>None</code> <code>on_exit_callback</code> <code>Callable</code> <p>The function to call upon exiting a step. Default is None.</p> <code>None</code> Source code in <code>datarails/step.py</code> <pre><code>def __init__(\n    self,\n    dbx: DataBox,\n    ctx: DataRailsContext,\n    on_entry_callback: Optional[Callable] = None,\n    on_exit_callback: Optional[Callable] = None,\n) -&gt; None:\n\"\"\"\n    Constructs all the necessary attributes for the DataRailsStep object.\n\n    Args:\n        dbx (DataBox): The data box object that stores and handles data for the step.\n        ctx (DataRailsContext): The context object that provides additional data and functionality.\n        on_entry_callback (Callable, optional): The function to call upon entering a step. Default is None.\n        on_exit_callback (Callable, optional): The function to call upon exiting a step. Default is None.\n    \"\"\"\n    self.dbx = dbx\n    self.ctx = ctx\n    self.on_entry_callback = on_entry_callback\n    self.on_exit_callback = on_exit_callback\n    self.step_method_name_iterator = None\n</code></pre>"},{"location":"step/#datarails.step.DataRailsStep.__str__","title":"<code>__str__()</code>","text":"<p>Returns a user-friendly string representation of the instance, in this case, the class name.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the class.</p> Source code in <code>datarails/step.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"\n    Returns a user-friendly string representation of the instance, in this case, the class name.\n\n    Returns:\n        str: The name of the class.\n    \"\"\"\n    return self.__class__.__name__\n</code></pre>"},{"location":"step/#datarails.step.DataRailsStep.advance","title":"<code>advance()</code>","text":"<p>Advances to the next 'step_' method in the pipeline, if available. This method can be used to control the execution of steps, for example in debugging scenarios.</p> Source code in <code>datarails/step.py</code> <pre><code>def advance(self) -&gt; None:\n\"\"\"\n    Advances to the next 'step_' method in the pipeline, if available.\n    This method can be used to control the execution of steps, for example in debugging scenarios.\n    \"\"\"\n\n    if not self.step_method_name_iterator:\n        self.step_method_name_iterator = iter(self.step_methods)\n\n    method_name = next(self.step_method_name_iterator, None)\n\n    if method_name:\n        method = getattr(self, method_name)\n        method()\n    else:\n        print(\"All steps have been executed.\")\n</code></pre>"},{"location":"step/#datarails.step.DataRailsStep.reset","title":"<code>reset()</code>","text":"<p>Resets the iterator that yields names of step methods, allowing the steps to be run from the beginning.</p> Source code in <code>datarails/step.py</code> <pre><code>def reset(self) -&gt; None:\n\"\"\"\n    Resets the iterator that yields names of step methods, allowing the steps to be run from the beginning.\n    \"\"\"\n    self.step_method_name_iterator = None\n</code></pre>"},{"location":"step/#datarails.step.DataRailsStep.run","title":"<code>run()</code>","text":"<p>Runs all the steps in the order they were declared in the child class. The order is fixed and cannot be changed. Each 'step_' method is called in turn.</p> <p>on_entry_callback is called at the beginning, if provided. on_exit_callback is called at the end, if provided.</p> <p>Returns:</p> Name Type Description <code>DataBox</code> <code>DataBox</code> <p>The updated DataBox after all steps have been run.</p> Source code in <code>datarails/step.py</code> <pre><code>def run(self) -&gt; DataBox:\n\"\"\"\n    Runs all the steps in the order they were declared in the child class.\n    The order is fixed and cannot be changed. Each 'step_' method is called in turn.\n\n    on_entry_callback is called at the beginning, if provided.\n    on_exit_callback is called at the end, if provided.\n\n    Returns:\n        DataBox: The updated DataBox after all steps have been run.\n    \"\"\"\n    if self.on_entry_callback:\n        self.on_entry_callback()\n\n    for method_name in self.step_methods:\n        method = getattr(self, method_name)\n        method()\n\n    if self.on_exit_callback:\n        self.on_exit_callback()\n\n    return self.dbx\n</code></pre>"}]}